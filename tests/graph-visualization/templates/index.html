<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Force Graph</title>
    <script src="//unpkg.com/3d-force-graph"></script>
</head>
<body>
    <div id="3d-graph"></div>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>

    <script>
        const wsHost = window.location.host;
        const ws = new WebSocket(`ws://${wsHost}/ws`);

        const graphData = {
            nodes: [],
            links: []
        }

        let graph = null;

        function forwardEvents(thisGraph) {
            thisGraph.onNodeClick((node, event) => {
                console.log(`Node clicked: ${node.id}`);
                ws.send(JSON.stringify({"type": "event", "mode": "nodeClick", "node": node, "event": event}));
            });
            thisGraph.onNodeRightClick((node, event) => {
                console.log(`Node right-clicked: ${node.id}`);
                ws.send(JSON.stringify({"type": "event", "mode": "nodeRightClick", "node": node, "event": event}));
            });
            thisGraph.onNodeHover((node, prevNode) => {
                console.log(`Node hovered: ${node ? node.id : null}`);
                ws.send(JSON.stringify({"type": "event", "mode": "nodeHover", "node": node, "prevNode": prevNode}));
            });
            thisGraph.onNodeDrag((node, translate) => {
                console.log(`Node dragged: ${node.id}`);
                ws.send(JSON.stringify({"type": "event", "mode": "nodeDrag", "node": node, "translate": translate}));
            });
            thisGraph.onNodeDragEnd((node, translate) => {
                console.log(`Node drag ended: ${node.id}`);
                ws.send(JSON.stringify({"type": "event", "mode": "nodeDragEnd", "node": node, "translate": translate}));
            });
            thisGraph.onLinkClick((link, event) => {
                console.log(`Link clicked: ${link.source} -> ${link.target}`);
                ws.send(JSON.stringify({"type": "event", "mode": "linkClick", "link": link, "event": event}));
            });
            thisGraph.onLinkRightClick((link, event) => {
                console.log(`Link right-clicked: ${link.source} -> ${link.target}`);
                ws.send(JSON.stringify({"type": "event", "mode": "linkRightClick", "link": link, "event": event}));
            });
            thisGraph.onLinkHover((link, prevLink) => {
                console.log(`Link hovered: ${link ? link.source + ' -> ' + link.target : null}`);
                ws.send(JSON.stringify({"type": "event", "mode": "linkHover", "link": link, "prevLink": prevLink}));
            });
            thisGraph.onBackgroundClick(event => {
                console.log('Background clicked');
                ws.send(JSON.stringify({"type": "event", "mode": "backgroundClick", "event": event}));
            });
            thisGraph.onBackgroundRightClick(event => {
                console.log('Background right-clicked');
                ws.send(JSON.stringify({"type": "event", "mode": "backgroundRightClick", "event": event}));
            });
        }

        function initGraph(configOptions) {
            console.log('Initializing graph with options', configOptions)
            graph = ForceGraph3D(configOptions)(document.getElementById('3d-graph'));
            graph.graphData(graphData);
            forwardEvents(graph);
        }

        function runGraphAction(action, argumentArray, argumentObject, actionId) {
            console.log(`Running action ${action} with arguments`, argumentArray, argumentObject);

            let returnValue = null;

            if (action === 'initGraph') {
                initGraph(argumentObject);

            } else if (!graph) {
                console.error('Graph not initialized');

            } else {
                if (action === 'graphData') {
                    if (argumentObject.length < 1) {
                        returnValue = graph.graphData();

                    } else {
                        const { nodes, links } = graph.graphData();

                        // 1. remove
                        //  1. all old node ids that are not in the new list
                        //  2. all old links that have a source and target that is not in the new list
                        // 2. add
                        //  1. all new nodes that are not in the old list
                        //  2. all new links that have a source and target that is not in the old list
                        // 3. update
                        //  1. all nodes with ids that are in both lists but have different properties
                        //  2. all links with source and target that are in both lists but have different properties

                        /*
                        const oldNodeIds = nodes.map(node => node.id);
                        const newNodeIds = argumentObject.nodes.map(node => node.id);

                        const oldLinkIds = links.map(link => `${link.source}-${link.target}`);
                        const newLinkIds = argumentObject.links.map(link => `${link.source}-${link.target}`);

                        const nodesToRemove = nodes.filter(node => !newNodeIds.includes(node.id));
                        const linksToRemove = links.filter(link => !newLinkIds.includes(`${link.source}-${link.target}`));

                        const nodesToAdd = argumentObject.nodes.filter(node => !oldNodeIds.includes(node.id));
                        const linksToAdd = argumentObject.links.filter(link => !oldLinkIds.includes(`${link.source}-${link.target}`));

                        const nodesToUpdate = argumentObject.nodes.filter(node => oldNodeIds.includes(node.id));
                        const linksToUpdate = argumentObject.links.filter(link => oldLinkIds.includes(`${link.source}-${link.target}`));

                        nodesToRemove.forEach(node => {
                            const index = nodes.indexOf(node);
                            nodes.splice(index, 1);
                        });

                        linksToRemove.forEach(link => {
                            const index = links.indexOf(link);
                            links.splice(index, 1);
                        });

                        nodesToAdd.forEach(node => {
                            nodes.push(node);
                        });

                        linksToAdd.forEach(link => {
                            links.push(link);
                        });

                        nodesToUpdate.forEach(node => {
                            const index = nodes.findIndex(n => n.id === node.id);
                            nodes[index] = node;
                        });

                        linksToUpdate.forEach(link => {
                            const index = links.findIndex(l => l.source === link.source && l.target === link.target);
                            links[index] = link;
                        });
                        */

                        nodes.splice(0, nodes.length);
                        links.splice(0, links.length);

                        argumentObject.nodes.forEach(eachNode => {
                            nodes.push(eachNode);
                        });
                        argumentObject.links.forEach(eachLink => {
                            links.push(eachLink);
                        });

                        graph.graphData({ nodes, links });

                        // graph.graphData(argumentObject);
                    }

                } else {
                    const method = graph[action];

                    if (typeof method === 'function') {
                        const arguments = argumentArray.concat([argumentObject]);
                        returnValue = method.apply(graph, arguments);

                    } else {
                        console.error(`Method ${action} not found`);
                    }
                }
            }

            console.log(`Sending confirmation for action id ${actionId}`);
            ws.send(JSON.stringify({ "type": "confirmation", "actionId": actionId, "returnValue": returnValue }));
        }

        ws.addEventListener("open", () => {
            console.log(`Connected to server at ${wsHost}`);
        });

        ws.addEventListener("close", () => {
            console.log(`Disconnected from server at ${wsHost}`);
        });

        ws.addEventListener("message", event => {
            console.log(`Received message from server: ${event.data}`);
            const data = JSON.parse(event.data);
            runGraphAction(data["action"], data["positionalArguments"], data["keywordArguments"], data["actionId"]);
        });
    </script>

</body>
</html>
